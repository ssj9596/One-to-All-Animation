from collections import OrderedDict
import numpy as np
from .aspect import ASPECT_RATIOS, get_closest_ratio

# config中, key是分辨率
# val的 k是time，v的第一个是prob 第二个是batch_size 
# 问题： 如何确保一样的aspect ratio落在同一个batch？ prob是tuple的时候是什么情况
# 

bucket_config = {# 在prob中，可以设置两个概率，第一个是resolution分桶，第二个是T分桶；当只设置一个时，只有resolution分桶概率，T只会落到满足要求的最大的那个T分桶中，比如这里让93帧的分桶第一个概率为0，则在没有设置第二个概率的情况下所有T>93的数据会被丢弃
    # "256":  {1: (1.0, 297), 25: (1, 40), 51: (1, 20), 102: (1, 10), 204: (1, 5)},
    # "240p": {1: (1.0, 297), 25: (1, 40), 51: (1, 20), 102: (1, 10), 204: (1, 5)}, 
    # "360p": {1: (1.0, 141), 25: (1, 16), 51: (1, 8), 102: (1, 4), 204: (1, 2)},
    # "512":  {1: (1.0, 141), 25: (1, 16), 51: (1, 8), 102: (1, 4), 204: (1, 2)},
    # "256":     {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 0.5), 2), 25: ((1, 0.4), 2), 33: ((1, 0.3), 2)},
    # "240p":    {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 0.5), 2), 25: ((1, 0.4), 2), 33: ((1, 0.3), 2)},
    # "360p":    {1: (1, 32), 9: ((1, 1), 4), 17: ((1, 1), 4), 25: ((1, 1), 4), 33: ((1, 1), 4), 41: ((1, 1), 4)},
    # "512":    {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 1), 2), 25: ((1, 1), 2), 33: ((1, 1), 2), 41: ((1, 1), 2)},
    "default": {1: (1, 16), 9: ((1, 1), 4), 17: ((1, 1), 4), 25: ((1, 1), 4), 33: ((1, 1), 4), 41: ((1, 1), 4), 49: ((1, 1), 4), 57: ((1, 1), 4)},
    # "cogvideo": {49: ((1, 1), 1)},
}

bucket_config_768 = {# 在prob中，可以设置两个概率，第一个是resolution分桶，第二个是T分桶；当只设置一个时，只有resolution分桶概率，T只会落到满足要求的最大的那个T分桶中，比如这里让93帧的分桶第一个概率为0，则在没有设置第二个概率的情况下所有T>93的数据会被丢弃
    # "256":  {1: (1.0, 297), 25: (1, 40), 51: (1, 20), 102: (1, 10), 204: (1, 5)},
    # "240p": {1: (1.0, 297), 25: (1, 40), 51: (1, 20), 102: (1, 10), 204: (1, 5)}, 
    # "360p": {1: (1.0, 141), 25: (1, 16), 51: (1, 8), 102: (1, 4), 204: (1, 2)},
    # "512":  {1: (1.0, 141), 25: (1, 16), 51: (1, 8), 102: (1, 4), 204: (1, 2)},
    # "256":     {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 0.5), 2), 25: ((1, 0.4), 2), 33: ((1, 0.3), 2)},
    # "240p":    {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 0.5), 2), 25: ((1, 0.4), 2), 33: ((1, 0.3), 2)},
    # "360p":    {1: (1, 32), 9: ((1, 1), 4), 17: ((1, 1), 4), 25: ((1, 1), 4), 33: ((1, 1), 4), 41: ((1, 1), 4)},
    # "512":    {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 1), 2), 25: ((1, 1), 2), 33: ((1, 1), 2), 41: ((1, 1), 2)},
    "1024": {1: (1, 16), 9: ((1, 1), 1), 17: ((1, 1), 1), 25: ((1, 1), 1), 33: ((1, 1), 1), 41: ((1, 1), 1), 49: ((1, 1), 1), 57: ((1, 1), 1), 65: ((1, 1), 1), 73: ((1, 1), 1), 81: ((1, 1), 1)},
    # "cogvideo": {49: ((1, 1), 1)},
}

multires_bucket_config = {# 在prob中，可以设置两个概率，第一个是resolution分桶，第二个是T分桶；当只设置一个时，只有resolution分桶概率，T只会落到满足要求的最大的那个T分桶中，比如这里让93帧的分桶第一个概率为0，则在没有设置第二个概率的情况下所有T>93的数据会被丢弃
    # "256":  {1: (1.0, 297), 25: (1, 40), 51: (1, 20), 102: (1, 10), 204: (1, 5)},
    # "240p": {1: (1.0, 297), 25: (1, 40), 51: (1, 20), 102: (1, 10), 204: (1, 5)}, 
    # "360p": {1: (1.0, 141), 25: (1, 16), 51: (1, 8), 102: (1, 4), 204: (1, 2)},
    # "512":  {1: (1.0, 141), 25: (1, 16), 51: (1, 8), 102: (1, 4), 204: (1, 2)},
    # "256":     {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 0.5), 2), 25: ((1, 0.4), 2), 33: ((1, 0.3), 2)},
    # "240p":    {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 0.5), 2), 25: ((1, 0.4), 2), 33: ((1, 0.3), 2)},
    # "360p":    {1: (1, 32), 9: ((1, 1), 4), 17: ((1, 1), 4), 25: ((1, 1), 4), 33: ((1, 1), 4), 41: ((1, 1), 4)},
    "512": {1: (1, 16), 9: ((1, 1), 4), 17: ((1, 1), 4), 25: ((1, 1), 4), 33: ((1, 1), 4), 41: ((1, 1), 4), 49: ((1, 1), 4), 57: ((1, 1), 4), 65: ((1, 1), 4), 73: ((1, 1), 4), 81: ((1, 1), 4)},
    # "default": {1: (1, 16), 9: ((1, 1), 4), 17: ((1, 1), 4), 25: ((1, 1), 4), 33: ((1, 1), 4), 41: ((1, 1), 4), 49: ((1, 1), 4), 57: ((1, 1), 4)},
    # "cogvideo": {49: ((1, 1), 1)},
}

cogvideo_bucket_config = {# 在prob中，可以设置两个概率，第一个是resolution分桶，第二个是T分桶；当只设置一个时，只有resolution分桶概率，T只会落到满足要求的最大的那个T分桶中，比如这里让93帧的分桶第一个概率为0，则在没有设置第二个概率的情况下所有T>93的数据会被丢弃
    # "256":  {1: (1.0, 297), 25: (1, 40), 51: (1, 20), 102: (1, 10), 204: (1, 5)},
    # "240p": {1: (1.0, 297), 25: (1, 40), 51: (1, 20), 102: (1, 10), 204: (1, 5)}, 
    # "360p": {1: (1.0, 141), 25: (1, 16), 51: (1, 8), 102: (1, 4), 204: (1, 2)},
    # "512":  {1: (1.0, 141), 25: (1, 16), 51: (1, 8), 102: (1, 4), 204: (1, 2)},
    # "256":     {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 0.5), 2), 25: ((1, 0.4), 2), 33: ((1, 0.3), 2)},
    # "240p":    {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 0.5), 2), 25: ((1, 0.4), 2), 33: ((1, 0.3), 2)},
    # "360p":    {1: (1, 32), 9: ((1, 1), 4), 17: ((1, 1), 4), 25: ((1, 1), 4), 33: ((1, 1), 4), 41: ((1, 1), 4)},
    # "512":    {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 1), 2), 25: ((1, 1), 2), 33: ((1, 1), 2), 41: ((1, 1), 2)},
    # "default": {1: (1, 16), 9: ((1, 1), 4), 17: ((1, 1), 4), 25: ((1, 1), 4), 33: ((1, 1), 4), 41: ((1, 1), 4), 49: ((1, 1), 4), 57: ((1, 1), 4)},
    "cogvideo": {1: (1, 1), 49: ((1, 1), 1)},
}


mochi_vid_bucket_config = {# 在prob中，可以设置两个概率，第一个是resolution分桶，第二个是T分桶；当只设置一个时，只有resolution分桶概率，T只会落到满足要求的最大的那个T分桶中，比如这里让93帧的分桶第一个概率为0，则在没有设置第二个概率的情况下所有T>93的数据会被丢弃
    # "256":  {1: (1.0, 297), 25: (1, 40), 51: (1, 20), 102: (1, 10), 204: (1, 5)},
    # "240p": {1: (1.0, 297), 25: (1, 40), 51: (1, 20), 102: (1, 10), 204: (1, 5)}, 
    # "360p": {1: (1.0, 141), 25: (1, 16), 51: (1, 8), 102: (1, 4), 204: (1, 2)},
    # "512":  {1: (1.0, 141), 25: (1, 16), 51: (1, 8), 102: (1, 4), 204: (1, 2)},
    # "256":     {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 0.5), 2), 25: ((1, 0.4), 2), 33: ((1, 0.3), 2)},
    # "240p":    {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 0.5), 2), 25: ((1, 0.4), 2), 33: ((1, 0.3), 2)},
    # "360p":    {1: (1, 32), 9: ((1, 1), 4), 17: ((1, 1), 4), 25: ((1, 1), 4), 33: ((1, 1), 4), 41: ((1, 1), 4)},
    # "512":    {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 1), 2), 25: ((1, 1), 2), 33: ((1, 1), 2), 41: ((1, 1), 2)},
    # "default": {1: (1, 16), 9: ((1, 1), 4), 17: ((1, 1), 4), 25: ((1, 1), 4), 33: ((1, 1), 4), 41: ((1, 1), 4), 49: ((1, 1), 4), 57: ((1, 1), 4)},
    # "256": {1: (1, 1), 31: ((1, 1), 1)},
    # "240p": {1: (1, 1), 31: ((1, 1), 1)},
    # "360p": {1: (1, 1), 31: ((1, 1), 1)},
    "512": {29: ((1, 1), 1)},
    # "480p": {1: (1, 1), 31: ((1, 1), 1)},
}

mochi_bucket_config = {# 在prob中，可以设置两个概率，第一个是resolution分桶，第二个是T分桶；当只设置一个时，只有resolution分桶概率，T只会落到满足要求的最大的那个T分桶中，比如这里让93帧的分桶第一个概率为0，则在没有设置第二个概率的情况下所有T>93的数据会被丢弃
    # "256":  {1: (1.0, 297), 25: (1, 40), 51: (1, 20), 102: (1, 10), 204: (1, 5)},
    # "240p": {1: (1.0, 297), 25: (1, 40), 51: (1, 20), 102: (1, 10), 204: (1, 5)}, 
    # "360p": {1: (1.0, 141), 25: (1, 16), 51: (1, 8), 102: (1, 4), 204: (1, 2)},
    # "512":  {1: (1.0, 141), 25: (1, 16), 51: (1, 8), 102: (1, 4), 204: (1, 2)},
    # "256":     {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 0.5), 2), 25: ((1, 0.4), 2), 33: ((1, 0.3), 2)},
    # "240p":    {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 0.5), 2), 25: ((1, 0.4), 2), 33: ((1, 0.3), 2)},
    # "360p":    {1: (1, 32), 9: ((1, 1), 4), 17: ((1, 1), 4), 25: ((1, 1), 4), 33: ((1, 1), 4), 41: ((1, 1), 4)},
    # "512":    {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 1), 2), 25: ((1, 1), 2), 33: ((1, 1), 2), 41: ((1, 1), 2)},
    # "default": {1: (1, 16), 9: ((1, 1), 4), 17: ((1, 1), 4), 25: ((1, 1), 4), 33: ((1, 1), 4), 41: ((1, 1), 4), 49: ((1, 1), 4), 57: ((1, 1), 4)},
    # "256": {1: (1, 1), 31: ((1, 1), 1)},
    # "240p": {1: (1, 1), 31: ((1, 1), 1)},
    # "360p": {1: (1, 1), 31: ((1, 1), 1)},
    "512": {1: (1, 1), 29: ((1, 1), 1)},
    # "512": {29: ((1, 1), 1)},
    # "480p": {1: (1, 1), 31: ((1, 1), 1)},
}
bucket_config_stage1 = {# 在prob中，可以设置两个概率，第一个是resolution分桶，第二个是T分桶；当只设置一个时，只有resolution分桶概率，T只会落到满足要求的最大的那个T分桶中，比如这里让93帧的分桶第一个概率为0，则在没有设置第二个概率的情况下所有T>93的数据会被丢弃
    "384":{1: (1, 1), 29: ((1, 1), 1)},
    # "448":{1: (0.5, 1), 29: ((0.5, 1), 1)},
    "512": {1: (0.5, 1), 29: ((0.5, 1), 1)},
}

bucket_config_stage2 = {# 在prob中，可以设置两个概率，第一个是resolution分桶，第二个是T分桶；当只设置一个时，只有resolution分桶概率，T只会落到满足要求的最大的那个T分桶中，比如这里让93帧的分桶第一个概率为0，则在没有设置第二个概率的情况下所有T>93的数据会被丢弃
    # "384":{1: (1, 1), 29: ((1, 1), 1)},
    # "448":{1: (0.5, 1), 29: ((0.5, 1), 1)},
    "512": {1: (1, 1), 29: ((1, 0.95), 1)},
    "768": {1: (0.2, 1), 29: ((0.2, 0.95), 1)},
}


bucket_config_stage2_vid = {# 在prob中，可以设置两个概率，第一个是resolution分桶，第二个是T分桶；当只设置一个时，只有resolution分桶概率，T只会落到满足要求的最大的那个T分桶中，比如这里让93帧的分桶第一个概率为0，则在没有设置第二个概率的情况下所有T>93的数据会被丢弃
    "384":{29: ((1, 1), 1)},
    "512": {29: ((0.5, 1), 1)},
    "768": {29: ((0.2, 1), 1)},
}


bucket_config_768_768 = {# 在prob中，可以设置两个概率，第一个是resolution分桶，第二个是T分桶；当只设置一个时，只有resolution分桶概率，T只会落到满足要求的最大的那个T分桶中，比如这里让93帧的分桶第一个概率为0，则在没有设置第二个概率的情况下所有T>93的数据会被丢弃
    "512": {1: (1, 1), 29: ((1, 0.95), 1)},
    "768": {1: (0.5, 1), 29: ((0.5, 1), 1)},
}

bucket_config_768_768_v2 = {# 在prob中，可以设置两个概率，第一个是resolution分桶，第二个是T分桶；当只设置一个时，只有resolution分桶概率，T只会落到满足要求的最大的那个T分桶中，比如这里让93帧的分桶第一个概率为0，则在没有设置第二个概率的情况下所有T>93的数据会被丢弃
    "512": {1: (1, 1), 29: ((1, 0.95), 1)},
    "768": {1: (0.8, 1), 29: ((0.8, 0.95), 1)},
}



bucket_config_960_960 = {# 在prob中，可以设置两个概率，第一个是resolution分桶，第二个是T分桶；当只设置一个时，只有resolution分桶概率，T只会落到满足要求的最大的那个T分桶中，比如这里让93帧的分桶第一个概率为0，则在没有设置第二个概率的情况下所有T>93的数据会被丢弃
    # "256":  {1: (1.0, 297), 25: (1, 40), 51: (1, 20), 102: (1, 10), 204: (1, 5)},
    # "240p": {1: (1.0, 297), 25: (1, 40), 51: (1, 20), 102: (1, 10), 204: (1, 5)}, 
    # "360p": {1: (1.0, 141), 25: (1, 16), 51: (1, 8), 102: (1, 4), 204: (1, 2)},
    # "512":  {1: (1.0, 141), 25: (1, 16), 51: (1, 8), 102: (1, 4), 204: (1, 2)},
    # "256":     {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 0.5), 2), 25: ((1, 0.4), 2), 33: ((1, 0.3), 2)},
    # "240p":    {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 0.5), 2), 25: ((1, 0.4), 2), 33: ((1, 0.3), 2)},
    # "360p":    {1: (1, 32), 9: ((1, 1), 4), 17: ((1, 1), 4), 25: ((1, 1), 4), 33: ((1, 1), 4), 41: ((1, 1), 4)},
    # "512":    {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 1), 2), 25: ((1, 1), 2), 33: ((1, 1), 2), 41: ((1, 1), 2)},
    # "default": {1: (1, 16), 9: ((1, 1), 4), 17: ((1, 1), 4), 25: ((1, 1), 4), 33: ((1, 1), 4), 41: ((1, 1), 4), 49: ((1, 1), 4), 57: ((1, 1), 4)},
    # "256": {1: (1, 1), 31: ((1, 1), 1)},
    # "240p": {1: (1, 1), 31: ((1, 1), 1)},
    # "360p": {1: (1, 1), 31: ((1, 1), 1)},
    "512": {1: (1, 1), 29: ((1, 1), 1)},
    "768": {1: (0.5, 1), 29: ((0.5, 1), 1)},
    "720p": {1: (0.3, 1), 29: ((0.3, 1), 1)},
    # "480p": {1: (1, 1), 31: ((1, 1), 1)},
}
bucket_config_960_full = {# 在prob中，可以设置两个概率，第一个是resolution分桶，第二个是T分桶；当只设置一个时，只有resolution分桶概率，T只会落到满足要求的最大的那个T分桶中，比如这里让93帧的分桶第一个概率为0，则在没有设置第二个概率的情况下所有T>93的数据会被丢弃
    "384":{1: (1, 1), 29: ((1, 1), 1)},
    "512": {1: (0.5, 1), 29: ((0.5, 1), 1)},
    "768": {1: (0.3, 1), 29: ((0.3, 1), 1)},
    "720p": {1: (0.2, 1), 29: ((0.2, 1), 1)},
    # "480p": {1: (1, 1), 31: ((1, 1), 1)},
}

bucket_config_768_full = {# 在prob中，可以设置两个概率，第一个是resolution分桶，第二个是T分桶；当只设置一个时，只有resolution分桶概率，T只会落到满足要求的最大的那个T分桶中，比如这里让93帧的分桶第一个概率为0，则在没有设置第二个概率的情况下所有T>93的数据会被丢弃
    "384":{1: (1, 1), 29: ((1, 1), 1)},
    "512": {1: (0.5, 1), 29: ((0.5, 1), 1)},
    "768": {1: (0.2, 1), 29: ((0.2, 1), 1)},
    # "480p": {1: (1, 1), 31: ((1, 1), 1)},
}


cogvideo_1_5_bucket_config = {# 在prob中，可以设置两个概率，第一个是resolution分桶，第二个是T分桶；当只设置一个时，只有resolution分桶概率，T只会落到满足要求的最大的那个T分桶中，比如这里让93帧的分桶第一个概率为0，则在没有设置第二个概率的情况下所有T>93的数据会被丢弃
    # "256":  {1: (1.0, 297), 25: (1, 40), 51: (1, 20), 102: (1, 10), 204: (1, 5)},
    # "240p": {1: (1.0, 297), 25: (1, 40), 51: (1, 20), 102: (1, 10), 204: (1, 5)}, 
    # "360p": {1: (1.0, 141), 25: (1, 16), 51: (1, 8), 102: (1, 4), 204: (1, 2)},
    # "512":  {1: (1.0, 141), 25: (1, 16), 51: (1, 8), 102: (1, 4), 204: (1, 2)},
    # "256":     {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 0.5), 2), 25: ((1, 0.4), 2), 33: ((1, 0.3), 2)},
    # "240p":    {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 0.5), 2), 25: ((1, 0.4), 2), 33: ((1, 0.3), 2)},
    # "360p":    {1: (1, 32), 9: ((1, 1), 4), 17: ((1, 1), 4), 25: ((1, 1), 4), 33: ((1, 1), 4), 41: ((1, 1), 4)},
    # "512":    {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 1), 2), 25: ((1, 1), 2), 33: ((1, 1), 2), 41: ((1, 1), 2)},
    # "default": {1: (1, 16), 9: ((1, 1), 4), 17: ((1, 1), 4), 25: ((1, 1), 4), 33: ((1, 1), 4), 41: ((1, 1), 4), 49: ((1, 1), 4), 57: ((1, 1), 4)},
    "cogvideo_1_5": {1: (1, 1), 81: ((1, 1), 1)},
}

cogvideo_1_5_multires_bucket_config = {# 在prob中，可以设置两个概率，第一个是resolution分桶，第二个是T分桶；当只设置一个时，只有resolution分桶概率，T只会落到满足要求的最大的那个T分桶中，比如这里让93帧的分桶第一个概率为0，则在没有设置第二个概率的情况下所有T>93的数据会被丢弃
    # "256":  {1: (1.0, 297), 25: (1, 40), 51: (1, 20), 102: (1, 10), 204: (1, 5)},
    # "240p": {1: (1.0, 297), 25: (1, 40), 51: (1, 20), 102: (1, 10), 204: (1, 5)}, 
    # "360p": {1: (1.0, 141), 25: (1, 16), 51: (1, 8), 102: (1, 4), 204: (1, 2)},
    # "512":  {1: (1.0, 141), 25: (1, 16), 51: (1, 8), 102: (1, 4), 204: (1, 2)},
    # "256":     {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 0.5), 2), 25: ((1, 0.4), 2), 33: ((1, 0.3), 2)},
    # "240p":    {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 0.5), 2), 25: ((1, 0.4), 2), 33: ((1, 0.3), 2)},
    # "360p":    {1: (1, 32), 9: ((1, 1), 4), 17: ((1, 1), 4), 25: ((1, 1), 4), 33: ((1, 1), 4), 41: ((1, 1), 4)},
    # "512":    {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 1), 2), 25: ((1, 1), 2), 33: ((1, 1), 2), 41: ((1, 1), 2)},
    # "default": {1: (1, 16), 9: ((1, 1), 4), 17: ((1, 1), 4), 25: ((1, 1), 4), 33: ((1, 1), 4), 41: ((1, 1), 4), 49: ((1, 1), 4), 57: ((1, 1), 4)},
    "cogvideo_1_5_multi_res": {1: (1, 1), 17: (1, 1), 33: (1, 1), 49: (1, 1)},
}


valid_bucket_config = {# 在prob中，可以设置两个概率，第一个是resolution分桶，第二个是T分桶；当只设置一个时，只有resolution分桶概率，T只会落到满足要求的最大的那个T分桶中，比如这里让93帧的分桶第一个概率为0，则在没有设置第二个概率的情况下所有T>93的数据会被丢弃
    # "256":  {1: (1.0, 297), 25: (1, 40), 51: (1, 20), 102: (1, 10), 204: (1, 5)},
    # "240p": {1: (1.0, 297), 25: (1, 40), 51: (1, 20), 102: (1, 10), 204: (1, 5)}, 
    # "360p": {1: (1.0, 141), 25: (1, 16), 51: (1, 8), 102: (1, 4), 204: (1, 2)},
    # "512":  {1: (1.0, 141), 25: (1, 16), 51: (1, 8), 102: (1, 4), 204: (1, 2)},
    # "256":     {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 0.5), 2), 25: ((1, 0.4), 2), 33: ((1, 0.3), 2)},
    # "240p":    {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 0.5), 2), 25: ((1, 0.4), 2), 33: ((1, 0.3), 2)},
    # "360p":    {1: (1, 32), 9: ((1, 1), 4), 17: ((1, 1), 4), 25: ((1, 1), 4), 33: ((1, 1), 4), 41: ((1, 1), 4)},
    # "512":    {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 1), 2), 25: ((1, 1), 2), 33: ((1, 1), 2), 41: ((1, 1), 2)},
    "default": {1: (1, 16), 49: ((1, 1), 2)},
}

cache_bucket_config = {# 在prob中，可以设置两个概率，第一个是resolution分桶，第二个是T分桶；当只设置一个时，只有resolution分桶概率，T只会落到满足要求的最大的那个T分桶中，比如这里让93帧的分桶第一个概率为0，则在没有设置第二个概率的情况下所有T>93的数据会被丢弃
    # "256":  {1: (1.0, 297), 25: (1, 40), 51: (1, 20), 102: (1, 10), 204: (1, 5)},
    # "240p": {1: (1.0, 297), 25: (1, 40), 51: (1, 20), 102: (1, 10), 204: (1, 5)}, 
    # "360p": {1: (1.0, 141), 25: (1, 16), 51: (1, 8), 102: (1, 4), 204: (1, 2)},
    # "512":  {1: (1.0, 141), 25: (1, 16), 51: (1, 8), 102: (1, 4), 204: (1, 2)},
    # "256":     {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 0.5), 2), 25: ((1, 0.4), 2), 33: ((1, 0.3), 2)},
    # "240p":    {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 0.5), 2), 25: ((1, 0.4), 2), 33: ((1, 0.3), 2)},
    # "360p":    {1: (1, 32), 9: ((1, 1), 4), 17: ((1, 1), 4), 25: ((1, 1), 4), 33: ((1, 1), 4), 41: ((1, 1), 4)},
    # "512":    {1: (1, 16), 9: ((1, 1), 2), 17: ((1, 1), 2), 25: ((1, 1), 2), 33: ((1, 1), 2), 41: ((1, 1), 2)},
    "default": {1: (1, 16), 9: ((1, 1), 4), 17: ((1, 1), 4), 25: ((1, 1), 4), 33: ((1, 1), 4), 41: ((1, 1), 4), 49: ((1, 1), 4), 57: ((1, 1), 4), 65: ((1, 1), 4), 73: ((1, 1), 4), 81: ((1, 1), 4)}, #89: ((1, 1), 4), 97: ((1, 1), 4), 105: ((1, 1), 4), 113: ((1, 1), 4), 121: ((1, 1), 4)
    # "cogvideo": {49: ((1, 1), 1)},
}


valid_bucket_configs = {
    'default': bucket_config,
    "cogvideo": cogvideo_bucket_config,
    "cogvideo_1_5": cogvideo_1_5_bucket_config,
    "cogvideo_1_5_multi_res": cogvideo_1_5_multires_bucket_config,
    "valid": valid_bucket_config,
    "multires_512": multires_bucket_config,
    "768p": bucket_config_768,
    "cache_bucket": cache_bucket_config,
    "mochi": mochi_bucket_config,
    "mochi_vid": mochi_vid_bucket_config,
    "stage1": bucket_config_stage1,
    "stage2": bucket_config_stage2,
    "stage2_vid": bucket_config_stage2_vid,
    "768": bucket_config_768_768,
    "768_v2":bucket_config_768_768_v2,
    "768_full": bucket_config_768_full,
    "960": bucket_config_960_960,
    "960_full": bucket_config_960_full,
}

def find_approximate_hw(hw, hw_dict, approx=0.8):
    for k, v in hw_dict.items():
        if hw >= v * approx:
            return k
    return None


def find_closet_smaller_bucket(t, t_dict, frame_interval):
    # process image
    if t == 1:
        if 1 in t_dict:
            return 1
        else:
            return None
    # process video
    for k, v in t_dict.items():
        if t >= v * frame_interval and v != 1:
            return k
    return None


class Bucket:
    def __init__(self, bucket_config):
        for key in bucket_config:
            assert key in ASPECT_RATIOS, f"Aspect ratio {key} not found."
        # wrap config with OrderedDict
        bucket_probs = OrderedDict()
        bucket_bs = OrderedDict()
        #sorted了，因此会严格按照分辨率
        bucket_names = sorted(bucket_config.keys(), key=lambda x: ASPECT_RATIOS[x][0], reverse=True) # ['2048', '1080p', '1024', '720p', '480p', '512', '360p', '240p', '256', '144p']
        for key in bucket_names:
            bucket_time_names = sorted(bucket_config[key].keys(), key=lambda x: x, reverse=True) # [1]
            bucket_probs[key] = OrderedDict({k: bucket_config[key][k][0] for k in bucket_time_names}) # [('2048', OrderedDict([(1, 0.05)]))]
            bucket_bs[key] = OrderedDict({k: bucket_config[key][k][1] for k in bucket_time_names}) # [('2048', OrderedDict([(1, 5)]))]

        # first level: HW
        num_bucket = 0
        hw_criteria = dict()
        t_criteria = dict()
        ar_criteria = dict()
        bucket_id = OrderedDict()
        bucket_id_cnt = 0
        for k1, v1 in bucket_probs.items():
            hw_criteria[k1] = ASPECT_RATIOS[k1][0] # 像素总数
            t_criteria[k1] = dict()
            ar_criteria[k1] = dict()
            bucket_id[k1] = dict()
            for k2, _ in v1.items():
                t_criteria[k1][k2] = k2
                bucket_id[k1][k2] = bucket_id_cnt
                bucket_id_cnt += 1
                ar_criteria[k1][k2] = dict()
                for k3, v3 in ASPECT_RATIOS[k1][1].items(): # 遍历不同ar
                    ar_criteria[k1][k2][k3] = v3
                    num_bucket += 1

        self.bucket_probs = bucket_probs
        self.bucket_bs = bucket_bs
        self.bucket_id = bucket_id
        self.hw_criteria = hw_criteria
        self.t_criteria = t_criteria
        self.ar_criteria = ar_criteria
        self.num_bucket = num_bucket
        #TODO: 增加logging
        print("Number of buckets: %s", num_bucket)

    def get_bucket_id(self, T, H, W, frame_interval=1, seed=None):
        # import pdb
        # pdb.set_trace()
        resolution = H * W
        approx = 0.70

        fail = True
        for hw_id, t_criteria in self.bucket_probs.items():
            # 分辨率小跳过
            if resolution < self.hw_criteria[hw_id] * approx:
                continue

            # if sample is an image
            if T == 1:
                if 1 in t_criteria:
                    rng = np.random.default_rng(seed + self.bucket_id[hw_id][1])
                    if rng.random() < t_criteria[1]:
                        fail = False
                        t_id = 1
                        break
                else:
                    continue

            # otherwise, find suitable t_id for video
            t_fail = True
            for t_id, prob in t_criteria.items():
                rng = np.random.default_rng(seed + self.bucket_id[hw_id][t_id])
                if isinstance(prob, tuple): #注意这里的逻辑，只有prob是一个tuple的时候，第二个prob才表示T分桶的变化，即一定概率落到更小的T分桶，否则，不会落到更小的T分桶
                    prob_t = prob[1]
                    if rng.random() > prob_t:
                        continue
                # if (T-1) >= (t_id-1) * frame_interval and t_id != 1: #T-1 > (t_id-1) * frame_interval是撑得最满的
                # 允许视频数据只取1帧
                if (T-1) >= (t_id-1) * frame_interval:
                    t_fail = False
                    break
            if t_fail:
                continue

            # leave the loop if prob is high enough
            if isinstance(prob, tuple):
                prob = prob[0]
            if prob >= 1 or rng.random() < prob:
                fail = False
                break
        if fail:
            return None

        # get aspect ratio id
        ar_criteria = self.ar_criteria[hw_id][t_id]
        ar_id = get_closest_ratio(H, W, ar_criteria)
        if ar_id is None:
            return None
        return hw_id, t_id, ar_id

    def get_thw(self, bucket_id):
        assert len(bucket_id) == 3
        T = self.t_criteria[bucket_id[0]][bucket_id[1]]
        H, W = self.ar_criteria[bucket_id[0]][bucket_id[1]][bucket_id[2]]
        return T, H, W

    def get_prob(self, bucket_id):
        return self.bucket_probs[bucket_id[0]][bucket_id[1]]

    def get_batch_size(self, bucket_id):
        return self.bucket_bs[bucket_id[0]][bucket_id[1]]

    def __len__(self):
        return self.num_bucket


def closet_smaller_bucket(value, bucket):
    for i in range(1, len(bucket)):
        if value < bucket[i]:
            return bucket[i - 1]
    return bucket[-1]


if __name__ == "__main__":
    import pdb; pdb.set_trace()
    bucket = Bucket(mochi_bucket_config)